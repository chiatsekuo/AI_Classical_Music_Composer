import sys
import argparse
import pickle
import numpy
from music21 import instrument, note, stream, chord
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import Dropout
from keras.layers import Bidirectional
from keras.layers import LSTM
from keras.layers import BatchNormalization as BatchNorm
from keras.layers import Activation

def generate(note_path, weight, n_notes):
	with open('notes/'+note_path, 'rb') as filepath:
		notes = pickle.load(filepath)
	pitchnames = sorted(set(item for item in notes))
	n_vocab = len(set(notes))

	network_input, normalized_input = prepare_sequences(notes, pitchnames, n_vocab)
	model = create_network(normalized_input, n_vocab, weight)
	prediction_output = generate_notes(model, network_input, pitchnames, n_vocab, n_notes)
	create_midi(prediction_output)

def prepare_sequences(notes, pitchnames, n_vocab):
	note_to_int = dict((note, number) for number, note in enumerate(pitchnames))

	sequence_length = 100
	network_input = []
	output = []
	for i in range(0, len(notes) - sequence_length, 1):
		sequence_in = notes[i:i + sequence_length]
		sequence_out = notes[i + sequence_length]
		network_input.append([note_to_int[char] for char in sequence_in])
		output.append(note_to_int[sequence_out])

	n_patterns = len(network_input)

	normalized_input = numpy.reshape(network_input, (n_patterns, sequence_length, 1))
	normalized_input = normalized_input / float(n_vocab)

	return (network_input, normalized_input)

def create_network(network_input, n_vocab, weight):
	model = Sequential()

	model.add(Bidirectional(LSTM(
		128,
		input_shape=(network_input.shape[1], network_input.shape[2]),
		recurrent_dropout=0.3,
		return_sequences=True
	)))
	model.add(LSTM(128, return_sequences=True, recurrent_dropout=0.3,))
	model.add(LSTM(128))
	model.add(BatchNorm())
	model.add(Dropout(0.3))
	model.add(Dense(128))
	model.add(Activation('relu'))
	model.add(BatchNorm())
	model.add(Dropout(0.3))
	model.add(Dense(n_vocab))
	model.add(Activation('softmax'))

	model.compile(loss='categorical_crossentropy', optimizer='rmsprop')

	model.build(input_shape=network_input.shape)
	
	# Load the weights to each node
	model.load_weights('./trained_weights/'+str(weight)+'.hdf5')

	return model

def generate_notes(model, network_input, pitchnames, n_vocab, n_notes):
	start = numpy.random.randint(10, len(network_input)-1)

	int_to_note = dict((number, note) for number, note in enumerate(pitchnames))

	pattern = network_input[start]
	prediction_output = []

	# generate 500 notes
	for note_index in range(n_notes):
		prediction_input = numpy.reshape(pattern, (1, len(pattern), 1))
		prediction_input = prediction_input / float(n_vocab)

		prediction = model.predict(prediction_input, verbose=0)

		index = numpy.argmax(prediction)
		result = int_to_note[index]
		prediction_output.append(result)

		pattern.append(index)
		pattern = pattern[1:len(pattern)]

	return prediction_output

def create_midi(prediction_output):
	""" convert the output from the prediction to notes and create a midi file
		from the notes """
	offset = 0
	output_notes = []

	# create note and chord objects based on the values generated by the model
	for pattern in prediction_output:
		# pattern is a chord
		if ('.' in pattern) or pattern.isdigit():
			notes_in_chord = pattern.split('.')
			notes = []
			for current_note in notes_in_chord:
				new_note = note.Note(int(current_note))
				new_note.storedInstrument = instrument.Piano()
				notes.append(new_note)
			new_chord = chord.Chord(notes)
			new_chord.offset = offset
			output_notes.append(new_chord)
		# pattern is a note
		else:
			new_note = note.Note(pattern)
			new_note.offset = offset
			new_note.storedInstrument = instrument.Piano()
			output_notes.append(new_note)

		# increase offset each iteration so that notes do not stack
		offset += 0.5

	midi_stream = stream.Stream(output_notes)

	midi_stream.write('midi', fp='output.mid')

if __name__ == '__main__':

	parser = argparse.ArgumentParser(description='Train the Bi-LSTM model.')
	parser.add_argument('string', metavar='note_path', type=str, nargs='?',
		help='the path name of the training set (notes)')
	parser.add_argument('string', metavar='network_weight', type=str, nargs='?',
		help='the optimal pre-trained weight')
	parser.add_argument('int', metavar='n_notes', type=int, nargs='?',
		help='the number of notes in the generated music')
	args = parser.parse_args()
	
	try:
		note_path = sys.argv[1:][0]
		weight = sys.argv[1:][1]
		n_notes = int(sys.argv[1:][2])
		generate(note_path, weight, n_notes)
	except:
		print("Please specify the \"training set\", the \"optimal weight\", and the \"number of notes\" as three arguments")
